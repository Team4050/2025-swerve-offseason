# CTRE Phoenix Swerve Drive System Architecture

## Table of Contents

1. [System Overview](#system-overview)
2. [Component Breakdown](#component-breakdown)
3. [Code Architecture](#code-architecture)
4. [Configuration Deep Dive](#configuration-deep-dive)
5. [Integration Points](#integration-points)
6. [Best Practices](#best-practices)

---

## System Overview

### The Big Picture

Your swerve drive system is built on **CTRE Phoenix 6**, which provides a comprehensive framework for controlling complex mechanisms. Here's how everything fits together:

```
┌─────────────────────────────────────────────────────────────────┐
│                        ROBOT CODE LAYER                          │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │          CommandSwerveDrivetrain (Subsystem)             │  │
│  │  - WPILib Command-based wrapper                          │  │
│  │  - Integrates with autonomous commands                   │  │
│  │  - Handles simulation and telemetry                      │  │
│  └──────────────────────────────────────────────────────────┘  │
│                             ↓                                    │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │              TunerSwerveDrivetrain                        │  │
│  │  - Generated by Tuner X                                   │  │
│  │  - Extends SwerveDrivetrain base class                   │  │
│  │  - Contains robot-specific constants                     │  │
│  └──────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                             ↓
┌─────────────────────────────────────────────────────────────────┐
│                    PHOENIX 6 API LAYER                           │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │              SwerveDrivetrain Base Class                  │  │
│  │  - Core swerve logic and control                         │  │
│  │  - Odometry management                                    │  │
│  │  - Module coordination                                    │  │
│  └──────────────────────────────────────────────────────────┘  │
│                             ↓                                    │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │              SwerveRequest API                            │  │
│  │  - FieldCentric, RobotCentric                            │  │
│  │  - FieldCentricFacingAngle                               │  │
│  │  - SwerveDriveBrake, Idle                                │  │
│  └──────────────────────────────────────────────────────────┘  │
│                             ↓                                    │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │              SwerveModule Classes                         │  │
│  │  - Individual module control (×4)                        │  │
│  │  - Drive + Steer motor coordination                      │  │
│  │  - Encoder feedback integration                          │  │
│  └──────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                             ↓
┌─────────────────────────────────────────────────────────────────┐
│                    HARDWARE LAYER                                │
│  ┌────────┐  ┌────────┐  ┌────────┐  ┌────────┐  ┌─────────┐ │
│  │TalonFX │  │TalonFX │  │TalonFX │  │TalonFX │  │Pigeon2  │ │
│  │Drive FL│  │Drive FR│  │Drive BL│  │Drive BR│  │  (IMU)  │ │
│  └────────┘  └────────┘  └────────┘  └────────┘  └─────────┘ │
│  ┌────────┐  ┌────────┐  ┌────────┐  ┌────────┐               │
│  │TalonFX │  │TalonFX │  │TalonFX │  │TalonFX │               │
│  │Steer FL│  │Steer FR│  │Steer BL│  │Steer BR│               │
│  └────────┘  └────────┘  └────────┘  └────────┘               │
│  ┌────────┐  ┌────────┐  ┌────────┐  ┌────────┐               │
│  │CANcoder│  │CANcoder│  │CANcoder│  │CANcoder│               │
│  │   FL   │  │   FR   │  │   BL   │  │   BR   │               │
│  └────────┘  └────────┘  └────────┘  └────────┘               │
│                                                                  │
│  Connected via: CAN Bus ("rio" or CANivore name)               │
└─────────────────────────────────────────────────────────────────┘
```

---

## Component Breakdown

### 1. TunerConstants.java (Configuration File)

**Location:** `src/main/java/frc/robot/generated/TunerConstants.java`

**Purpose:** Generated by Phoenix Tuner X - contains all robot-specific configuration

**Key Sections:**

#### A. Control Gains

```java
// STEER MOTOR PID + FF GAINS
private static final Slot0Configs steerGains = new Slot0Configs()
    .withKP(100)         // Proportional gain
    .withKI(0)           // Integral gain
    .withKD(0.5)         // Derivative gain
    .withKS(0.1)         // Static friction feedforward (Volts)
    .withKV(2.66)        // Velocity feedforward (V/(rot/s))
    .withKA(0)           // Acceleration feedforward (V/(rot/s²))
    .withStaticFeedforwardSign(...);

// DRIVE MOTOR PID + FF GAINS
private static final Slot0Configs driveGains = new Slot0Configs()
    .withKP(0.1)         // Proportional gain
    .withKI(0)           // Integral gain
    .withKD(0)           // Derivative gain
    .withKS(0)           // Static friction feedforward
    .withKV(0.124);      // Velocity feedforward (V/(m/s))
```

**When to modify:**

- After SysId characterization
- During tuning process
- When changing mechanical components (wheels, gearing)

#### B. Hardware Configuration

```java
// Motor and encoder types
private static final DriveMotorArrangement kDriveMotorType =
    DriveMotorArrangement.TalonFX_Integrated;
private static final SteerMotorArrangement kSteerMotorType =
    SteerMotorArrangement.TalonFX_Integrated;
private static final SteerFeedbackType kSteerFeedbackType =
    SteerFeedbackType.FusedCANcoder;

// CAN Bus configuration
public static final CANBus kCANBus = new CANBus("", "./logs/example.hoot");
// "" = roboRIO CAN bus
// Or specify CANivore: new CANBus("canivore_name")
```

**Options for SteerFeedbackType:**

- `FusedCANcoder`: Best - fuses CANcoder with motor sensor (Pro only, falls back to RemoteCANcoder)
- `SyncCANcoder`: Time-synced CANcoder (Pro only, falls back to RemoteCANcoder)
- `RemoteCANcoder`: Basic CANcoder feedback
- `BootToAbsolutePosition`: Uses TalonFX internal sensor (less accurate)

#### C. Physical Characteristics

```java
// Robot dimensions and mechanics
public static final LinearVelocity kSpeedAt12Volts = MetersPerSecond.of(4.58);
private static final double kCoupleRatio = 3.5714285714285716;
private static final double kDriveGearRatio = 6.746031746031747;
private static final double kSteerGearRatio = 21.428571428571427;
private static final Distance kWheelRadius = Inches.of(2);
private static final boolean kInvertLeftSide = false;
private static final boolean kInvertRightSide = true;
```

**When to modify:**

- Different wheel diameter
- Gearing changes
- Module orientation changes
- After measuring actual robot speed

#### D. Performance Limits

```java
// Current limiting for slip prevention
private static final Current kSlipCurrent = Amps.of(120);

// Individual motor current limits
private static final TalonFXConfiguration steerInitialConfigs = new TalonFXConfiguration()
    .withCurrentLimits(
        new CurrentLimitsConfigs()
            .withStatorCurrentLimit(Amps.of(60))
            .withStatorCurrentLimitEnable(true)
    );
```

#### E. Module-Specific Constants

```java
// Each module defined individually
private static final int kFrontLeftDriveMotorId = 1;
private static final int kFrontLeftSteerMotorId = 0;
private static final int kFrontLeftEncoderId = 0;
private static final Angle kFrontLeftEncoderOffset = Rotations.of(-0.XXX);
private static final Distance kFrontLeftXPos = Inches.of(10.5);
private static final Distance kFrontLeftYPos = Inches.of(10.5);
// ... repeated for FR, BL, BR
```

**Critical:** Encoder offsets must be calibrated precisely!

---

### 2. SwerveDrivetrain (Phoenix Base Class)

**Purpose:** Core Phoenix 6 swerve implementation (you don't modify this)

**Key Responsibilities:**

#### Odometry Management

```java
// Automatically handles:
- Pose2d tracking (robot position on field)
- Velocity estimation
- Integration with Pigeon 2.0 for heading
- Time-synchronized updates with CANivore (if Pro)
```

**Access in your code:**

```java
Pose2d currentPose = drivetrain.getState().Pose;
ChassisSpeeds currentSpeeds = drivetrain.getState().Speeds;
```

#### Module Control

```java
// Manages all 4 swerve modules:
- Applies control requests to all modules simultaneously
- Handles module state optimization (don't rotate >90°)
- Coordinates drive + steer for each module
- Applies coupling ratio compensation
```

#### Signal Management

```java
// Efficiently retrieves data from hardware:
- Uses StatusSignal API for low-latency reads
- Supports waitForAll() for synchronized reading
- Manages update frequencies automatically
```

---

### 3. SwerveRequest API (Control Interface)

**Purpose:** Defines HOW the robot should move

**Location:** Built into Phoenix 6, used in your `CommandSwerveDrivetrain`

#### Available Request Types

##### A. FieldCentric

```java
private final SwerveRequest.FieldCentric drive = new SwerveRequest.FieldCentric()
    .withDeadband(MaxSpeed * 0.1)
    .withRotationalDeadband(MaxAngularRate * 0.1)
    .withDriveRequestType(DriveRequestType.OpenLoopVoltage);
```

**Use:** Driver control with field-oriented driving

- `VelocityX/Y`: m/s in field coordinates (X = downfield, Y = left)
- `RotationalRate`: rad/s for rotation
- **Automatically** compensates for robot heading

**Configuration Options:**

```java
// Drive request types:
DriveRequestType.OpenLoopVoltage     // Direct voltage control (default, fastest)
DriveRequestType.Velocity            // Closed-loop velocity control (more accurate)

// Steer request types:
SteerRequestType.MotionMagic         // Smooth profiled motion
SteerRequestType.MotionMagicExpo     // Faster acceleration profile
```

##### B. FieldCentricFacingAngle

```java
private final SwerveRequest.FieldCentricFacingAngle driveToAngle =
    new SwerveRequest.FieldCentricFacingAngle()
    .withDeadband(MaxSpeed * 0.1);
```

**Use:** Drive while maintaining/seeking a specific heading

- Driver controls translation (X/Y)
- Robot automatically rotates to target angle
- Great for aiming at scoring locations

**Example:**

```java
// Drive while facing 90° (pointing left)
drivetrain.setControl(
    driveToAngle
        .withVelocityX(joystick.getY() * MaxSpeed)
        .withVelocityY(joystick.getX() * MaxSpeed)
        .withTargetDirection(Rotation2d.fromDegrees(90))
);
```

**Heading Controller PID:** Tuned via SysId rotation characterization

##### C. RobotCentric

```java
private final SwerveRequest.RobotCentric robotDrive = new SwerveRequest.RobotCentric();
```

**Use:** Direct control relative to robot

- Useful for autonomous or specific maneuvers
- X = forward/back, Y = left/right (relative to robot)

##### D. SwerveDriveBrake

```java
private final SwerveRequest.SwerveDriveBrake brake = new SwerveRequest.SwerveDriveBrake();
```

**Use:** "X" configuration for defense

- Points all modules toward center of robot
- Makes pushing much harder
- Activate with: `drivetrain.setControl(brake)`

##### E. Idle

```java
private final SwerveRequest.Idle idle = new SwerveRequest.Idle();
```

**Use:** Coast/do nothing

- Removes all control requests
- Motors go to neutral

##### F. SysId Requests (Testing Only)

```java
SwerveRequest.SysIdSwerveTranslation    // Characterize drive motors
SwerveRequest.SysIdSwerveSteerGains     // Characterize steer motors
SwerveRequest.SysIdSwerveRotation       // Characterize heading controller
```

**Use:** Only during tuning with WPILib SysId tool

---

### 4. CommandSwerveDrivetrain (Your Subsystem)

**Location:** `src/main/java/frc/robot/subsystems/CommandSwerveDrivetrain.java`

**Purpose:** Bridges Phoenix swerve with WPILib command-based framework

**Key Features:**

#### A. Command Factory Methods

```java
// Already implemented in your code:
public Command applyRequest(Supplier<SwerveRequest> requestSupplier) {
    return run(() -> this.setControl(requestSupplier.get()));
}
```

**Usage in RobotContainer:**

```java
drivetrain.applyRequest(() ->
    drive.withVelocityX(-joystick.getLeftY() * MaxSpeed)
         .withVelocityY(-joystick.getLeftX() * MaxSpeed)
         .withRotationalRate(-joystick.getRightX() * MaxAngularRate)
);
```

#### B. Simulation Support

```java
@Override
public void simulationPeriodic() {
    // Automatically updates simulated sensors
    updateSimState(kSimLoopPeriod, RobotController.getBatteryVoltage());
}
```

**Enables:**

- Testing autonomous paths without hardware
- Visualizing in AdvantageScope or Glass
- Path planning development

#### C. Telemetry Integration

```java
// Register custom telemetry function
registerTelemetry(logger -> {
    // Called automatically on every odometry update
    logger.telemeterize(getState());
});
```

**Integrated with:**

- Advantage Kit (if using)
- WPILib telemetry
- Custom dashboard solutions

#### D. SysId Integration

```java
// Built-in SysId routines for characterization
private final SysIdRoutine m_sysIdRoutineTranslation = ...
private final SysIdRoutine m_sysIdRoutineSteer = ...
private final SysIdRoutine m_sysIdRoutineRotation = ...

// Expose as commands:
public Command sysIdQuasistatic(Direction direction) {
    return m_sysIdRoutineTranslation.quasistatic(direction);
}
```

#### E. Alliance Perspective

```java
// Automatically flips controls for red alliance
private Rotation2d getOperatorPerspective() {
    return DriverStation.getAlliance()
        .map(allianceColor -> allianceColor == Alliance.Red
            ? kRedAlliancePerspectiveRotation
            : kBlueAlliancePerspectiveRotation)
        .orElse(kBlueAlliancePerspectiveRotation);
}
```

---

### 5. Pigeon 2.0 (IMU)

**Purpose:** Provides robot heading (yaw angle)

**Integration:**

- Automatically read by `SwerveDrivetrain`
- Fused with wheel odometry for accurate pose estimation
- Critical for field-centric control

**Configuration:**

```java
// In TunerConstants.java
private static final int kPigeonId = 2;
private static final Pigeon2Configuration pigeonConfigs = null; // Or custom config
```

**Best Practices:**

- Mount rigidly to chassis (no vibration)
- Mount level/flat
- Calibrate gyro before match (not required but helpful)
- Zero heading in `autonomousInit()` or at start of match

**Accessing in Code:**

```java
// Pigeon managed internally by SwerveDrivetrain
// Access heading via:
Rotation2d heading = drivetrain.getState().Pose.getRotation();
```

---

### 6. CANcoder (Absolute Encoders)

**Purpose:** Provides absolute wheel angle for each module

**Critical Configuration:**

```java
// Module-specific encoder offsets
private static final Angle kFrontLeftEncoderOffset = Rotations.of(-0.XXX);
```

**Calibration Process:**

1. Manually align all wheels straight forward
2. Read absolute positions in Tuner X
3. Set offsets to make aligned position = 0
4. Deploy and verify

**Feedback Types:**

- **FusedCANcoder** (Recommended, Pro license): Fuses CANcoder with TalonFX sensor
  - Benefits: Lower latency, less CAN traffic, more accurate
  - Requirement: Phoenix Pro license
- **RemoteCANcoder** (Free): Reads CANcoder over CAN bus
  - Works for all users but slightly higher latency

---

## Code Architecture

### Entry Points and Flow

#### 1. Robot Initialization (`Robot.java`)

```java
public class Robot extends TimedRobot {
    private RobotContainer m_robotContainer;

    @Override
    public void robotInit() {
        m_robotContainer = new RobotContainer();
        // RobotContainer creates CommandSwerveDrivetrain
        // Drivetrain initializes all modules, configures hardware
    }
}
```

#### 2. Subsystem Creation (`RobotContainer.java`)

```java
public class RobotContainer {
    // Drivetrain subsystem created with TunerConstants
    private final CommandSwerveDrivetrain drivetrain =
        TunerConstants.createDrivetrain();

    public RobotContainer() {
        configureBindings();
    }
}
```

#### 3. Control Bindings

```java
private void configureBindings() {
    // Default command: field-centric drive
    drivetrain.setDefaultCommand(
        drivetrain.applyRequest(() ->
            drive.withVelocityX(-joystick.getLeftY() * MaxSpeed)
                 .withVelocityY(-joystick.getLeftX() * MaxSpeed)
                 .withRotationalRate(-joystick.getRightX() * AngularRate)
        )
    );

    // Button bindings:
    controller.a().whileTrue(drivetrain.applyRequest(() -> brake));
    controller.b().onTrue(drivetrain.runOnce(() -> drivetrain.seedFieldCentric()));
}
```

#### 4. Periodic Execution Flow

```
robotPeriodic() [50Hz]
  └─> CommandScheduler.run()
        └─> drivetrain.periodic()
              └─> setControl(currentRequest)
                    └─> SwerveDrivetrain.setControl()
                          ├─> Converts SwerveRequest to module states
                          ├─> Optimizes module states (avoid >90° turns)
                          ├─> Applies control to all 8 motors
                          └─> Updates odometry asynchronously
```

**Key Point:** Odometry runs on separate thread at max CAN bus speed!

---

## Configuration Deep Dive

### Drivetrain Constants Structure

```java
public static final SwerveDrivetrainConstants DrivetrainConstants =
    new SwerveDrivetrainConstants()
        .withCANBusName(kCANBus.getName())
        .withPigeon2Id(kPigeonId)
        .withPigeon2Configs(pigeonConfigs)
        .withSupportsPro(true);  // Set based on license

// Module constants factory (shared configs)
private static final SwerveModuleConstantsFactory ConstantCreator =
    new SwerveModuleConstantsFactory()
        .withDriveMotorGearRatio(kDriveGearRatio)
        .withSteerMotorGearRatio(kSteerGearRatio)
        .withCouplingGearRatio(kCoupleRatio)
        .withWheelRadius(kWheelRadius)
        .withSteerMotorGains(steerGains)
        .withDriveMotorGains(driveGains)
        .withSteerMotorClosedLoopOutput(kSteerClosedLoopOutput)
        .withDriveMotorClosedLoopOutput(kDriveClosedLoopOutput)
        .withSlipCurrent(kSlipCurrent)
        .withSpeedAt12Volts(kSpeedAt12Volts)
        .withDriveMotorType(kDriveMotorType)
        .withSteerMotorType(kSteerMotorType)
        .withFeedbackSource(kSteerFeedbackType)
        .withDriveMotorInitialConfigs(driveInitialConfigs)
        .withSteerMotorInitialConfigs(steerInitialConfigs)
        .withEncoderInitialConfigs(encoderInitialConfigs)
        .withSteerInertia(kSteerInertia)  // Simulation only
        .withDriveInertia(kDriveInertia)  // Simulation only
        .withSteerFrictionVoltage(kSteerFrictionVoltage)  // Simulation
        .withDriveFrictionVoltage(kDriveFrictionVoltage); // Simulation
```

### Module Constants Creation

```java
// Front Left Module
private static final SwerveModuleConstants FrontLeft = ConstantCreator.createModuleConstants(
    kFrontLeftSteerMotorId,
    kFrontLeftDriveMotorId,
    kFrontLeftEncoderId,
    kFrontLeftEncoderOffset,
    kFrontLeftXPos,      // Distance from robot center
    kFrontLeftYPos,      // Distance from robot center
    kInvertLeftSide
);

// Repeated for FR, BL, BR...
```

---

## Integration Points

### WPILib Integration

#### Pose Estimation

```java
// Drivetrain automatically updates WPILib pose
Pose2d currentPose = drivetrain.getState().Pose;

// Can integrate with vision:
drivetrain.addVisionMeasurement(
    visionPose,
    timestamp,
    visionStdDevs  // Kalman filter uncertainties
);
```

#### PathPlanner Integration

```java
// SwerveDrivetrain provides PathPlanner support
public Command followPath(PathPlannerPath path) {
    return AutoBuilder.followPath(path);
}

// Configure in RobotContainer:
AutoBuilder.configure(
    drivetrain::getPose,
    drivetrain::resetPose,
    drivetrain::getChassisSpeeds,
    (speeds, feedforwards) -> drivetrain.setControl(
        new SwerveRequest.ApplyRobotSpeeds()
            .withSpeeds(speeds)
            .withWheelForceFeedforwardsX(feedforwards.robotRelativeForcesX())
            .withWheelForceFeedforwardsY(feedforwards.robotRelativeForcesY())
    ),
    new PPHolonomicDriveController(...),
    new RobotConfig(...),
    () -> DriverStation.getAlliance().orElse(Alliance.Blue) == Alliance.Red,
    drivetrain
);
```

#### AdvantageScope/Glass Visualization

```java
// In periodic():
SmartDashboard.putData("Drivetrain", drivetrain);
Field2d field = new Field2d();
field.setRobotPose(drivetrain.getState().Pose);
SmartDashboard.putData("Field", field);
```

### Phoenix Tools Integration

#### Signal Logger

```java
// Enable in robotInit():
if (isReal()) {
    SignalLogger.setPath("/media/sda1/logs/");  // USB drive
} else {
    SignalLogger.setPath("./logs/");  // Simulation
}
SignalLogger.start();

// Automatically logs all Phoenix signals
// Extract with Tuner X after match
```

#### Hoot File Replay

```java
// Simulate using logged data:
public static final CANBus kCANBus = new CANBus("", "./logs/match3.hoot");
// Replays exact CAN traffic for debugging
```

---

## Best Practices

### 1. Configuration Management

#### Version Control Strategy

```
✓ DO: Commit TunerConstants.java
✓ DO: Document why gains changed
✓ DO: Tag known-good configurations
✗ DON'T: Hand-edit generated sections
✗ DON'T: Lose working configurations
```

#### Configuration Backup

```java
// Before competition, backup working config:
// 1. Copy TunerConstants.java to safe location
// 2. Document robot weight, battery, wheel condition
// 3. Save Tuner X project file
```

### 2. Initialization Best Practices

#### Proper Initialization Order

```java
// In RobotContainer constructor:
public RobotContainer() {
    // 1. Create subsystems first
    drivetrain = TunerConstants.createDrivetrain();

    // 2. Configure button bindings
    configureBindings();

    // 3. Initialize autonomous chooser
    buildAutoChooser();

    // 4. Register telemetry (after everything initialized)
    registerTelemetry();
}
```

#### Reset Procedures

```java
@Override
public void autonomousInit() {
    // Always reset odometry at start of autonomous
    drivetrain.resetPose(startingPose);
    // Or seed field-centric if relying on vision
    drivetrain.seedFieldCentric();
}
```

### 3. Safety and Limits

#### Software Current Limiting

```java
// Prevent brownouts:
steerInitialConfigs.withCurrentLimits(
    new CurrentLimitsConfigs()
        .withStatorCurrentLimit(Amps.of(60))  // Steer limit
        .withStatorCurrentLimitEnable(true)
);

driveInitialConfigs.withCurrentLimits(
    new CurrentLimitsConfigs()
        .withStatorCurrentLimit(Amps.of(80))   // Drive limit
        .withStatorCurrentLimitEnable(true)
);
```

#### Voltage Compensation

```java
// Ensure consistent behavior regardless of battery voltage:
TalonFXConfiguration config = new TalonFXConfiguration()
    .withVoltageConfigs(
        new VoltageConfigs()
            .withPeakForwardVoltage(12)
            .withPeakReverseVoltage(-12)
    );
```

### 4. Debugging Tools

#### Enable Detailed Logging

```java
// In CommandSwerveDrivetrain:
@Override
public void periodic() {
    // Log important signals every cycle
    SmartDashboard.putNumber("Drive/Pose X", getState().Pose.getX());
    SmartDashboard.putNumber("Drive/Pose Y", getState().Pose.getY());
    SmartDashboard.putNumber("Drive/Heading", getState().Pose.getRotation().getDegrees());
    SmartDashboard.putNumber("Drive/Speed",
        Math.hypot(getState().Speeds.vxMetersPerSecond,
                   getState().Speeds.vyMetersPerSecond));
}
```

#### Module-Level Diagnostics

```java
// Access individual module states:
SwerveModuleState[] states = drivetrain.getState().ModuleStates;
for (int i = 0; i < 4; i++) {
    SmartDashboard.putNumber("Module" + i + "/Speed", states[i].speedMetersPerSecond);
    SmartDashboard.putNumber("Module" + i + "/Angle", states[i].angle.getDegrees());
}
```

### 5. Competition Readiness

#### Pre-Match Checklist

```
□ Verify all devices visible in Tuner X
□ Check for faults on all devices
□ Verify CANcoder offsets correct (wheels straight when enabled)
□ Test field-centric (drive forward = downfield regardless of heading)
□ Test brake mode (X formation works)
□ Verify autonomous paths load correctly
□ Check battery voltage >12.5V
□ Log path: verify USB drive mounted
```

#### Match Configuration

```java
// Disable non-essential logging during matches
if (DriverStation.isFRCMatch()) {
    SignalLogger.stop();  // Reduce CPU load
    // Keep critical logging only
}
```

### 6. Team Development Workflow

#### Code Organization

```
src/main/java/frc/robot/
├── subsystems/
│   └── CommandSwerveDrivetrain.java    [Team modifies - add features]
├── commands/
│   ├── auto/                            [Team creates - autonomous]
│   └── drive/                           [Team creates - teleop features]
├── generated/
│   └── TunerConstants.java              [Generated - manual tuning only]
└── RobotContainer.java                  [Team modifies - bindings]
```

#### Recommended Practices

1. **Don't Modify SwerveDrivetrain Base Class** - It's in the Phoenix library
2. **Extend CommandSwerveDrivetrain** - Add your features here
3. **Version Control TunerConstants** - Track configuration changes
4. **Document Custom SwerveRequests** - If you create your own
5. **Use Suppliers in Commands** - Allows runtime parameter changes

---

## Common Extension Points

### Adding Custom SwerveRequests

```java
// In CommandSwerveDrivetrain.java
public class CustomSwerveRequest implements SwerveRequest {
    private VelocityVoltage driveControl = new VelocityVoltage(0);
    private PositionVoltage steerControl = new PositionVoltage(0);

    @Override
    public StatusCode apply(SwerveControlRequestParameters parameters,
                           SwerveModule... modulesToApply) {
        // Custom control logic here
        for (SwerveModule module : modulesToApply) {
            module.getDriveMotor().setControl(driveControl.withVelocity(customVelocity));
            module.getSteerMotor().setControl(steerControl.withPosition(customAngle));
        }
        return StatusCode.OK;
    }
}
```

### Vision Integration Example

```java
// In CommandSwerveDrivetrain.java
public void updateVisionPose(Pose2d visionPose, double timestamp) {
    // Add vision measurement with appropriate uncertainties
    Matrix<N3, N1> visionStdDevs = VecBuilder.fill(0.5, 0.5, 0.5);  // X, Y, Theta
    addVisionMeasurement(visionPose, timestamp, visionStdDevs);
}

// In periodic():
if (visionHasTargets()) {
    updateVisionPose(getVisionPose(), getVisionTimestamp());
}
```

### Custom Telemetry

```java
// In constructor:
registerTelemetry((SwerveDriveState state) -> {
    // Custom telemetry logic
    Logger.recordOutput("Swerve/Pose", state.Pose);
    Logger.recordOutput("Swerve/ModuleStates", state.ModuleStates);
    Logger.recordOutput("Swerve/OdometryFrequency", state.OdometryPeriod);
});
```
